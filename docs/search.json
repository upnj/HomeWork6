[
  {
    "objectID": "HomeWork6.html",
    "href": "HomeWork6.html",
    "title": "HomeWork6",
    "section": "",
    "text": "The lapply() function is a variety of apply() that takes in a vector, a list, or a DataFrame as input and always outputs a list (“l” in the function name stands for “list”). The specified function applies to each element of the input object, hence the length of the resulting list is always equal to the input object’s length.\nThe syntax of this function is similar to the syntax of apply(), only here there is no need for the MARGIN parameter since the function applies element-wise for lists and vectors and column-wise for DataFrames:\npurr::map() is equivalent to purr functions. In the following link Hadley Wickham explained about the comparison of lapply() and map() functions. https://stackoverflow.com/questions/45101045/why-use-purrrmap-instead-of-lapply\n\n\n\n\n#result &lt;- lapply(my_list, function(x) cor(x, method =\"kendall\"))\n\nIn the above code lapply() applies a function to each element of the list.We use an anonymous function function(x) as the second argument to lapply(). Inside this anonymous function, we call cor(x, method = “kendall”). The x in the anonymous function represents each element of my_list in turn. The method = “kendall” argument is passed directly to the cor() function.\n\n\n\nThe two advantage of using purr functions over R basic functions are\n\nConsistent naming and behavior:\n\npurrr functions have more consistent and intuitive naming conventions. For example, map() is used for applying a function to each element of a list or vector, regardless of the output type. In contrast, base R has different functions like lapply(), sapply(), and vapply() for similar operations, which can be confusing for beginners. purrr functions also have more predictable return types. For instance, map() always returns a list, while sapply() in base R might return a vector, matrix, or list depending on the output, which can lead to unexpected behavior.\n\nType-specific variants and shortcuts:\n\npurrr provides type-specific variants of its functions, making it easier to ensure specific output types. For example:\nmap_dbl() for numeric output map_chr() for character output map_lgl() for logical output\nThese variants help catch type mismatches early and make the code’s intent clearer. purrr also offers shortcut syntax for common operations. For example, you can use map(list, “column_name”) to extract a specific column from each data frame in a list, which is more concise than writing a full anonymous function. These advantages contribute to more readable, maintainable, and less error-prone code, especially when working with complex nested data structures or performing multiple operations in sequence.\n\n\n\nA side-effect function in R is a function that modifies something outside of its local environment or performs an action beyond simply returning a value. These functions are called primarily for their side effects rather than for their return values.\nKey characteristics of side-effect functions include:\n\nThey often modify the global environment or external state.\nThey may perform I/O operations like writing to a file or printing to the console.\nTheir primary purpose is to cause some change or action, not to compute and return a value.\n\n\n\n\n\nprint(sd)\n\nfunction (x, na.rm = FALSE) \nsqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \n    na.rm = na.rm))\n&lt;bytecode: 0x000002740c31dd10&gt;\n&lt;environment: namespace:stats&gt;\n\n#&gt; function (x, na.rm = FALSE) \n#&gt; sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \n#&gt;     na.rm = na.rm))\n#&gt; &lt;bytecode: 0x0000000017e687b8&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\nsd &lt;- 12.2\n\nprint(sd)\n\n[1] 12.2\n\n#&gt; [1] 12.2\n\nsd(1:10)\n\n[1] 3.02765\n\n#&gt; [1] 3.02765\n\nR has separate namespaces for functions and variables. Depending on the context in which a name occurs, R will look up the name in one namespace or in the other.\nFor instance, the expression sd(1:10) is a call and the first element in a call must be the name of a function. Therefore, in this case, R will look for a function named sd.\nOn the other hand, the expression sd is not a call but a name, which could be either the name of a variable or the name of a function. In this case R will look first for the first object in the search path named sd regardless of whether it’s a function or another type of object."
  },
  {
    "objectID": "HomeWork6.html#what-is-the-purpose-of-the-lapply-function-what-is-the-equivalent-purr-function",
    "href": "HomeWork6.html#what-is-the-purpose-of-the-lapply-function-what-is-the-equivalent-purr-function",
    "title": "HomeWork6",
    "section": "",
    "text": "The lapply() function is a variety of apply() that takes in a vector, a list, or a DataFrame as input and always outputs a list (“l” in the function name stands for “list”). The specified function applies to each element of the input object, hence the length of the resulting list is always equal to the input object’s length.\nThe syntax of this function is similar to the syntax of apply(), only here there is no need for the MARGIN parameter since the function applies element-wise for lists and vectors and column-wise for DataFrames:\npurr::map() is equivalent to purr functions. In the following link Hadley Wickham explained about the comparison of lapply() and map() functions. https://stackoverflow.com/questions/45101045/why-use-purrrmap-instead-of-lapply"
  },
  {
    "objectID": "HomeWork6.html#suppose-we-have-a-list-called-my_list.-each-element-of-the-list-is-a-numeric-data-frame-all-columns-are-numeric.-we-want-use-lapply-to-run-the-code-cornumeric_matrix-method-kendall-on-each-element-of-the-list.-write-code-to-do-this-below-im-really-trying-to-ask-you-how-you-specify-method-kendall-when-calling-lapply",
    "href": "HomeWork6.html#suppose-we-have-a-list-called-my_list.-each-element-of-the-list-is-a-numeric-data-frame-all-columns-are-numeric.-we-want-use-lapply-to-run-the-code-cornumeric_matrix-method-kendall-on-each-element-of-the-list.-write-code-to-do-this-below-im-really-trying-to-ask-you-how-you-specify-method-kendall-when-calling-lapply",
    "title": "HomeWork6",
    "section": "",
    "text": "#result &lt;- lapply(my_list, function(x) cor(x, method =\"kendall\"))\n\nIn the above code lapply() applies a function to each element of the list.We use an anonymous function function(x) as the second argument to lapply(). Inside this anonymous function, we call cor(x, method = “kendall”). The x in the anonymous function represents each element of my_list in turn. The method = “kendall” argument is passed directly to the cor() function."
  },
  {
    "objectID": "HomeWork6.html#what-are-two-advantages-of-using-purrr-functions-instead-of-the-baser-apply-family",
    "href": "HomeWork6.html#what-are-two-advantages-of-using-purrr-functions-instead-of-the-baser-apply-family",
    "title": "HomeWork6",
    "section": "",
    "text": "The two advantage of using purr functions over R basic functions are\n\nConsistent naming and behavior:\n\npurrr functions have more consistent and intuitive naming conventions. For example, map() is used for applying a function to each element of a list or vector, regardless of the output type. In contrast, base R has different functions like lapply(), sapply(), and vapply() for similar operations, which can be confusing for beginners. purrr functions also have more predictable return types. For instance, map() always returns a list, while sapply() in base R might return a vector, matrix, or list depending on the output, which can lead to unexpected behavior.\n\nType-specific variants and shortcuts:\n\npurrr provides type-specific variants of its functions, making it easier to ensure specific output types. For example:\nmap_dbl() for numeric output map_chr() for character output map_lgl() for logical output\nThese variants help catch type mismatches early and make the code’s intent clearer. purrr also offers shortcut syntax for common operations. For example, you can use map(list, “column_name”) to extract a specific column from each data frame in a list, which is more concise than writing a full anonymous function. These advantages contribute to more readable, maintainable, and less error-prone code, especially when working with complex nested data structures or performing multiple operations in sequence."
  },
  {
    "objectID": "HomeWork6.html#what-is-a-side-effect-function",
    "href": "HomeWork6.html#what-is-a-side-effect-function",
    "title": "HomeWork6",
    "section": "",
    "text": "A side-effect function in R is a function that modifies something outside of its local environment or performs an action beyond simply returning a value. These functions are called primarily for their side effects rather than for their return values.\nKey characteristics of side-effect functions include:\n\nThey often modify the global environment or external state.\nThey may perform I/O operations like writing to a file or printing to the console.\nTheir primary purpose is to cause some change or action, not to compute and return a value."
  },
  {
    "objectID": "HomeWork6.html#why-can-you-name-a-variable-sd-in-a-function-and-not-cause-any-issues-with-the-sd-function",
    "href": "HomeWork6.html#why-can-you-name-a-variable-sd-in-a-function-and-not-cause-any-issues-with-the-sd-function",
    "title": "HomeWork6",
    "section": "",
    "text": "print(sd)\n\nfunction (x, na.rm = FALSE) \nsqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \n    na.rm = na.rm))\n&lt;bytecode: 0x000002740c31dd10&gt;\n&lt;environment: namespace:stats&gt;\n\n#&gt; function (x, na.rm = FALSE) \n#&gt; sqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \n#&gt;     na.rm = na.rm))\n#&gt; &lt;bytecode: 0x0000000017e687b8&gt;\n#&gt; &lt;environment: namespace:stats&gt;\n\nsd &lt;- 12.2\n\nprint(sd)\n\n[1] 12.2\n\n#&gt; [1] 12.2\n\nsd(1:10)\n\n[1] 3.02765\n\n#&gt; [1] 3.02765\n\nR has separate namespaces for functions and variables. Depending on the context in which a name occurs, R will look up the name in one namespace or in the other.\nFor instance, the expression sd(1:10) is a call and the first element in a call must be the name of a function. Therefore, in this case, R will look for a function named sd.\nOn the other hand, the expression sd is not a call but a name, which could be either the name of a variable or the name of a function. In this case R will look first for the first object in the search path named sd regardless of whether it’s a function or another type of object."
  },
  {
    "objectID": "HomeWork6.html#rmse-function",
    "href": "HomeWork6.html#rmse-function",
    "title": "HomeWork6",
    "section": "RMSE Function",
    "text": "RMSE Function\nWrite a basic function (call it getRMSE()) that takes in a vector of responses and a vector of predictions and outputs the RMSE. • If a value is missing for the vector of responses (i.e. an NA is present), allow for additional arguments to the mean() function (elipses) that removes the NA values in the computation.\n\ngetRMSE &lt;- function(y, y_hat, ...) {\n  # Check if the lengths of y and y_hat are the same\n  if (length(y) != length(y_hat)) {\n    stop(\"The lengths of actual values and predictions must be the same.\")\n  }\n  \n  # Remove pairs where y is NA\n  valid_indices &lt;- !is.na(y)\n  y &lt;- y[valid_indices]\n  y_hat &lt;- y_hat[valid_indices]\n  \n  # Calculate the squared differences\n  squared_diff &lt;- (y - y_hat)^2\n  \n  # Calculate the mean of squared differences, allowing for additional arguments\n  mean_squared_diff &lt;- mean(squared_diff, ...)\n  \n  # Calculate RMSE\n  rmse &lt;- sqrt(mean_squared_diff)\n  \n  return(rmse)\n}\n\nLet’s apply this function to some actual and predicted values\n\n# Example usage\nactual &lt;- c(1, 2, NA, 4, 5)\npredicted &lt;- c(1.1, 2.2, 2.9, 4.1, 5.2)\n\n# Using the function with default behavior (NA values removed)\nresult1 &lt;- getRMSE(actual, predicted)\nprint(result1)\n\n[1] 0.1581139\n\n# Explicitly specifying na.rm = TRUE\nresult2 &lt;- getRMSE(actual, predicted, na.rm = TRUE)\nprint(result2)\n\n[1] 0.1581139\n\n\nRun the following code to create some response values and predictions. set.seed(10) n &lt;- 100 x &lt;- runif(n) resp &lt;- 3 + 10 * x + rnorm(n) pred &lt;- predict(lm(resp ~ x), data.frame(x)) • Test your RMSE function using this data. • Repeat after replacing two of the response values with missing values (NA_real_). – Test your RMSE function with and without specifying the behavior to deal with missing values.\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nNow Let’s test our RMSE function with this data:\n\n# Test RMSE function with original data\nrmse_original &lt;- getRMSE(resp, pred)\nprint(paste(\"RMSE with original data:\", rmse_original))\n\n[1] \"RMSE with original data: 0.958167655151933\"\n\n\nNow Let’s replace two of the response values with NA_real_ and test again:\n\n# Replace two response values with NA\nresp_with_na &lt;- resp\nresp_with_na[c(5, 50)] &lt;- NA_real_\n\n# Test RMSE function with NA values, without specifying na.rm\nrmse_with_na &lt;- getRMSE(resp_with_na, pred)\nprint(paste(\"RMSE with NA values (default behavior):\", rmse_with_na))\n\n[1] \"RMSE with NA values (default behavior): 0.960318742971636\"\n\n# Test RMSE function with NA values, explicitly specifying na.rm = TRUE\nrmse_with_na_explicit &lt;- getRMSE(resp_with_na, pred, na.rm = TRUE)\nprint(paste(\"RMSE with NA values (explicitly specifying na.rm = TRUE):\", rmse_with_na_explicit))\n\n[1] \"RMSE with NA values (explicitly specifying na.rm = TRUE): 0.960318742971636\""
  },
  {
    "objectID": "HomeWork6.html#mae-function",
    "href": "HomeWork6.html#mae-function",
    "title": "HomeWork6",
    "section": "MAE Function",
    "text": "MAE Function\nAnother common metric for evaluating predictions is mean absolute deviation given by Write a function called getMAE() that follows the specifications of the getRMSE() function.\n\ngetMAE &lt;- function(y, y_hat, ...) {\n  # Check if the lengths of y and y_hat are the same\n  if (length(y) != length(y_hat)) {\n    stop(\"The lengths of actual values and predictions must be the same.\")\n  }\n  \n  # Remove pairs where y is NA\n  valid_indices &lt;- !is.na(y)\n  y &lt;- y[valid_indices]\n  y_hat &lt;- y_hat[valid_indices]\n  \n  # Calculate the absolute differences\n  abs_diff &lt;- abs(y - y_hat)\n  \n  # Calculate the mean of absolute differences, allowing for additional arguments\n  mae &lt;- mean(abs_diff, ...)\n  \n  return(mae)\n}\n\nRun the following code to create some response values and predictions.\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\n• Test your MAE function using this data.\n\n# Test MAE function with original data\nmae_original &lt;- getMAE(resp, pred)\nprint(paste(\"MAE with original data:\", mae_original))\n\n[1] \"MAE with original data: 0.815577593682669\"\n\n\n• Repeat after replacing two of the response values with missing values (NA_real_). – Test your MAE function with and without specifying the behavior to deal with missing values.\n\n# Replace two response values with NA\nresp_with_na &lt;- resp\nresp_with_na[c(5, 50)] &lt;- NA_real_\n\n# Test MAE function with NA values, without specifying na.rm\nmae_with_na &lt;- getMAE(resp_with_na, pred)\nprint(paste(\"MAE with NA values (default behavior):\", mae_with_na))\n\n[1] \"MAE with NA values (default behavior): 0.815463413520463\"\n\n# Test MAE function with NA values, explicitly specifying na.rm = TRUE\nmae_with_na_explicit &lt;- getMAE(resp_with_na, pred, na.rm = TRUE)\nprint(paste(\"MAE with NA values (explicitly specifying na.rm = TRUE):\", mae_with_na_explicit))\n\n[1] \"MAE with NA values (explicitly specifying na.rm = TRUE): 0.815463413520463\""
  },
  {
    "objectID": "HomeWork6.html#wrapper-function",
    "href": "HomeWork6.html#wrapper-function",
    "title": "HomeWork6",
    "section": "Wrapper Function",
    "text": "Wrapper Function\nLet’s create a wrapper function that can be used to get either or both metrics returned with a single function call. Do not rewrite your above two functions, call them inside the wrapper function (we would call the getRMSE() and getMAE() functions helper functions). When returning your values, give them appropriate names. • The function should check that two numeric (atomic) vectors have been passed (consider is.vector(), is.atomic(), and is.numeric()). If not, a message should print and the function should exit. • The function should return both metrics by default and include names. The behavior should be able to be changed using a character string of metrics to find.\n\ngetPredictionMetrics &lt;- function(actual, predicted, metrics = c(\"RMSE\", \"MAE\"), ...) {\n  # Check if inputs are numeric atomic vectors\n  if (!is.vector(actual) || !is.atomic(actual) || !is.numeric(actual) ||\n      !is.vector(predicted) || !is.atomic(predicted) || !is.numeric(predicted)) {\n    message(\"Error: Both inputs must be numeric atomic vectors.\")\n    return(NULL)\n  }\n  \n  # Check if lengths match\n  if (length(actual) != length(predicted)) {\n    message(\"Error: The lengths of actual and predicted values must be the same.\")\n    return(NULL)\n  }\n  \n  # Initialize results list\n  results &lt;- list()\n  \n  # Calculate requested metrics\n  if (\"RMSE\" %in% metrics) {\n    results$RMSE &lt;- getRMSE(actual, predicted, ...)\n  }\n  \n  if (\"MAE\" %in% metrics) {\n    results$MAE &lt;- getMAE(actual, predicted, ...)\n  }\n  \n  # Check if any valid metrics were calculated\n  if (length(results) == 0) {\n    message(\"Error: No valid metrics specified. Please use 'RMSE' and/or 'MAE'.\")\n    return(NULL)\n  }\n  \n  return(results)\n}\n\nRun the following code to create some response values and predictions.\n\nset.seed(10)\nn &lt;- 100\nx &lt;- runif(n)\nresp &lt;- 3 + 10 * x + rnorm(n)\npred &lt;- predict(lm(resp ~ x), data.frame(x))\n\nTest your new function using this data. Call it once asking for each metric individually and once specifying both metrics\n\n# RMSE only\nrmse_result &lt;- getPredictionMetrics(resp, pred, metrics = \"RMSE\")\nprint(\"RMSE only:\")\n\n[1] \"RMSE only:\"\n\nprint(rmse_result)\n\n$RMSE\n[1] 0.9581677\n\n# MAE only\nmae_result &lt;- getPredictionMetrics(resp, pred, metrics = \"MAE\")\nprint(\"MAE only:\")\n\n[1] \"MAE only:\"\n\nprint(mae_result)\n\n$MAE\n[1] 0.8155776\n\n# Both metrics\nboth_metrics &lt;- getPredictionMetrics(resp, pred)\nprint(\"Both metrics:\")\n\n[1] \"Both metrics:\"\n\nprint(both_metrics)\n\n$RMSE\n[1] 0.9581677\n\n$MAE\n[1] 0.8155776\n\n\n• Repeat with replacing two of the response values with missing values (NA_real_).\n\n# Replace two response values with NA\nresp_with_na &lt;- resp\nresp_with_na[c(5, 50)] &lt;- NA_real_\n\n# Both metrics with NA values\nboth_metrics_na &lt;- getPredictionMetrics(resp_with_na, pred)\nprint(\"Both metrics with NA values:\")\n\n[1] \"Both metrics with NA values:\"\n\nprint(both_metrics_na)\n\n$RMSE\n[1] 0.9603187\n\n$MAE\n[1] 0.8154634\n\n\n• Finally, test your function by passing it incorrect data (i.e. a data frame or something else instead of vectors)\n\n# Test with a data frame instead of a vector\ndf_test &lt;- getPredictionMetrics(as.data.frame(resp), pred)\n\nError: Both inputs must be numeric atomic vectors.\n\n# Test with mismatched lengths\nlength_test &lt;- getPredictionMetrics(resp[1:50], pred)\n\nError: The lengths of actual and predicted values must be the same.\n\n# Test with non-numeric data\nchar_test &lt;- getPredictionMetrics(as.character(resp), pred)\n\nError: Both inputs must be numeric atomic vectors."
  }
]